"""
Playwright Test Runner for Orchestrator-Generated Tests
========================================================

This module provides the test execution infrastructure. The actual test
code is generated by the orchestrator's agent based on the specific app
that was built - the agent knows the exact selectors, form fields, and
component structure.

Usage by orchestrator:
    1. Agent examines built app, generates test file at project_dir/e2e/tests.py
    2. Orchestrator calls run_generated_tests() to execute them
    3. Results are logged to Supabase

Direct usage (for generated test files):
    python playwright_tests.py --test-file ./e2e/tests.py \
        --url http://localhost:3000 \
        --supabase-url https://xxx.supabase.co \
        --supabase-anon-key xxx \
        --supabase-service-key xxx

Requires: pip install playwright httpx && playwright install chromium
"""

import argparse
import asyncio
import importlib.util
import json
import os
import random
import string
import sys
import time
from dataclasses import dataclass, field
from typing import Optional, Callable, Any

try:
    from playwright.async_api import async_playwright, Page, BrowserContext
except ImportError:
    print("Playwright not installed. Run: pip install playwright && playwright install chromium")
    sys.exit(1)

try:
    import httpx
except ImportError:
    print("httpx not installed. Run: pip install httpx")
    sys.exit(1)


# ─────────────────────────────────────────────
# Test Result Data Structures
# ─────────────────────────────────────────────

@dataclass
class TestResult:
    """Result of a single test scenario."""
    name: str
    status: str  # "PASS", "FAIL", "SKIP"
    duration_ms: float = 0
    error: Optional[str] = None
    details: dict = field(default_factory=dict)


@dataclass
class TestSuiteResult:
    """Results from the full test suite."""
    results: list[TestResult] = field(default_factory=list)
    total_duration_ms: float = 0

    @property
    def passed(self) -> int:
        return sum(1 for r in self.results if r.status == "PASS")

    @property
    def failed(self) -> int:
        return sum(1 for r in self.results if r.status == "FAIL")

    @property
    def skipped(self) -> int:
        return sum(1 for r in self.results if r.status == "SKIP")

    def to_dict(self) -> dict:
        return {
            "passed": self.passed,
            "failed": self.failed,
            "skipped": self.skipped,
            "total": len(self.results),
            "duration_ms": self.total_duration_ms,
            "results": [
                {
                    "name": r.name,
                    "status": r.status,
                    "duration_ms": r.duration_ms,
                    "error": r.error,
                    "details": r.details,
                }
                for r in self.results
            ]
        }


# ─────────────────────────────────────────────
# Test User Management (via Supabase Auth API)
# ─────────────────────────────────────────────

def generate_test_email() -> str:
    """Generate a unique test email."""
    random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    return f"playwright_test_{random_suffix}@test.local"


async def create_test_user(
    supabase_url: str,
    service_key: str,
    email: str,
    password: str = "testpass123!"
) -> dict:
    """Create a test user via Supabase Auth Admin API."""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{supabase_url}/auth/v1/admin/users",
            headers={
                "apikey": service_key,
                "Authorization": f"Bearer {service_key}",
                "Content-Type": "application/json",
            },
            json={
                "email": email,
                "password": password,
                "email_confirm": True,
            },
            timeout=10.0,
        )
        if response.status_code not in (200, 201):
            raise Exception(f"Failed to create user: {response.status_code} - {response.text}")
        return response.json()


async def delete_test_user(
    supabase_url: str,
    service_key: str,
    user_id: str
) -> bool:
    """Delete a test user via Supabase Auth Admin API."""
    async with httpx.AsyncClient() as client:
        response = await client.delete(
            f"{supabase_url}/auth/v1/admin/users/{user_id}",
            headers={
                "apikey": service_key,
                "Authorization": f"Bearer {service_key}",
            },
            timeout=10.0,
        )
        return response.status_code in (200, 204)


# ─────────────────────────────────────────────
# Test Context (passed to generated tests)
# ─────────────────────────────────────────────

@dataclass
class TestContext:
    """Context passed to generated test functions."""
    app_url: str
    supabase_url: str
    supabase_anon_key: str
    supabase_service_key: str
    user_a_email: str
    user_a_password: str
    user_b_email: str
    user_b_password: str
    browser_context_a: BrowserContext
    browser_context_b: BrowserContext

    async def new_page_a(self) -> Page:
        """Create a new page in user A's browser context."""
        return await self.browser_context_a.new_page()

    async def new_page_b(self) -> Page:
        """Create a new page in user B's browser context."""
        return await self.browser_context_b.new_page()


# ─────────────────────────────────────────────
# Test Execution
# ─────────────────────────────────────────────

async def run_single_test(
    test_func: Callable,
    test_name: str,
    ctx: TestContext,
) -> TestResult:
    """Run a single test function and capture result."""
    start = time.time()
    try:
        await test_func(ctx)
        return TestResult(
            name=test_name,
            status="PASS",
            duration_ms=(time.time() - start) * 1000,
        )
    except Exception as e:
        return TestResult(
            name=test_name,
            status="FAIL",
            duration_ms=(time.time() - start) * 1000,
            error=str(e),
        )


async def run_generated_tests(
    test_file_path: str,
    app_url: str,
    supabase_url: str,
    supabase_anon_key: str,
    supabase_service_key: str,
    headless: bool = True,
) -> TestSuiteResult:
    """
    Run tests from a generated test file.

    The test file should define async functions prefixed with 'test_' that
    accept a TestContext argument. Example:

        async def test_auth_redirect(ctx: TestContext):
            page = await ctx.new_page_a()
            await page.goto(ctx.app_url)
            # ... assertions ...

        async def test_login_flow(ctx: TestContext):
            ...
    """
    suite_start = time.time()
    results = TestSuiteResult()

    # Load the generated test module
    if not os.path.exists(test_file_path):
        results.results.append(TestResult(
            name="load_tests",
            status="FAIL",
            error=f"Test file not found: {test_file_path}",
        ))
        results.total_duration_ms = (time.time() - suite_start) * 1000
        return results

    try:
        spec = importlib.util.spec_from_file_location("generated_tests", test_file_path)
        test_module = importlib.util.module_from_spec(spec)

        # Inject our utilities into the module namespace
        test_module.TestContext = TestContext
        test_module.TestResult = TestResult
        test_module.generate_test_email = generate_test_email
        test_module.create_test_user = create_test_user
        test_module.delete_test_user = delete_test_user

        spec.loader.exec_module(test_module)
    except Exception as e:
        results.results.append(TestResult(
            name="load_tests",
            status="FAIL",
            error=f"Failed to load test file: {e}",
        ))
        results.total_duration_ms = (time.time() - suite_start) * 1000
        return results

    # Find all test functions
    test_functions = [
        (name, func) for name, func in vars(test_module).items()
        if name.startswith("test_") and callable(func)
    ]

    if not test_functions:
        results.results.append(TestResult(
            name="find_tests",
            status="FAIL",
            error="No test functions found (functions must start with 'test_')",
        ))
        results.total_duration_ms = (time.time() - suite_start) * 1000
        return results

    # Create test users
    user_a_email = generate_test_email()
    user_b_email = generate_test_email()
    password = "testpass123!"
    user_a_id = None
    user_b_id = None

    try:
        print(f"  Creating test users...")
        user_a = await create_test_user(supabase_url, supabase_service_key, user_a_email, password)
        user_a_id = user_a.get("id")
        user_b = await create_test_user(supabase_url, supabase_service_key, user_b_email, password)
        user_b_id = user_b.get("id")
        print(f"  ✓ Test users: {user_a_email}, {user_b_email}")
    except Exception as e:
        results.results.append(TestResult(
            name="create_test_users",
            status="FAIL",
            error=str(e),
        ))
        results.total_duration_ms = (time.time() - suite_start) * 1000
        return results

    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=headless)

            # Run each test with FRESH browser contexts for isolation
            # This ensures auth state doesn't leak between tests
            for test_name, test_func in test_functions:
                print(f"  Running: {test_name}")

                # Create fresh contexts for this test (no cookies, no persisted login)
                context_a = await browser.new_context()
                context_b = await browser.new_context()

                ctx = TestContext(
                    app_url=app_url,
                    supabase_url=supabase_url,
                    supabase_anon_key=supabase_anon_key,
                    supabase_service_key=supabase_service_key,
                    user_a_email=user_a_email,
                    user_a_password=password,
                    user_b_email=user_b_email,
                    user_b_password=password,
                    browser_context_a=context_a,
                    browser_context_b=context_b,
                )

                result = await run_single_test(test_func, test_name, ctx)
                results.results.append(result)
                status_emoji = {"PASS": "✅", "FAIL": "❌", "SKIP": "⏭"}.get(result.status, "❓")
                print(f"    {status_emoji} {result.status}" + (f": {result.error}" if result.error else ""))

                # Close contexts after each test to ensure clean slate for next test
                await context_a.close()
                await context_b.close()

            await browser.close()

    except Exception as e:
        results.results.append(TestResult(
            name="browser_execution",
            status="FAIL",
            error=str(e),
        ))

    finally:
        # Clean up test users
        print(f"  Cleaning up test users...")
        try:
            if user_a_id:
                await delete_test_user(supabase_url, supabase_service_key, user_a_id)
            if user_b_id:
                await delete_test_user(supabase_url, supabase_service_key, user_b_id)
        except Exception as e:
            print(f"  ⚠ Cleanup failed: {e}")

    results.total_duration_ms = (time.time() - suite_start) * 1000
    return results


def run_tests_sync(
    test_file_path: str,
    app_url: str,
    supabase_url: str,
    supabase_anon_key: str,
    supabase_service_key: str,
    headless: bool = True,
    timeout: Optional[int] = None,
) -> TestSuiteResult:
    """Synchronous wrapper for running tests.

    Args:
        timeout: Optional timeout in seconds for the entire test suite.
    """
    async def run_with_timeout():
        if timeout:
            try:
                return await asyncio.wait_for(
                    run_generated_tests(
                        test_file_path=test_file_path,
                        app_url=app_url,
                        supabase_url=supabase_url,
                        supabase_anon_key=supabase_anon_key,
                        supabase_service_key=supabase_service_key,
                        headless=headless,
                    ),
                    timeout=timeout,
                )
            except asyncio.TimeoutError:
                result = TestSuiteResult()
                result.results.append(TestResult(
                    name="timeout",
                    status="FAIL",
                    error=f"Browser tests timed out after {timeout}s",
                ))
                return result
        else:
            return await run_generated_tests(
                test_file_path=test_file_path,
                app_url=app_url,
                supabase_url=supabase_url,
                supabase_anon_key=supabase_anon_key,
                supabase_service_key=supabase_service_key,
                headless=headless,
            )

    return asyncio.run(run_with_timeout())
# ─────────────────────────────────────────────
# CLI Interface
# ─────────────────────────────────────────────

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run Playwright tests from a generated test file")
    parser.add_argument("--test-file", required=True, help="Path to the generated test file")
    parser.add_argument("--url", required=True, help="App URL to test")
    parser.add_argument("--supabase-url", required=True, help="Supabase project URL")
    parser.add_argument("--supabase-anon-key", required=True, help="Supabase anon key")
    parser.add_argument("--supabase-service-key", required=True, help="Supabase service role key")
    parser.add_argument("--headed", action="store_true", help="Run with visible browser")
    parser.add_argument("--json", action="store_true", help="Output results as JSON")

    args = parser.parse_args()

    print(f"\n{'=' * 60}")
    print(f"  PLAYWRIGHT BROWSER TESTS")
    print(f"  Test file: {args.test_file}")
    print(f"  App URL: {args.url}")
    print(f"{'=' * 60}\n")

    results = run_tests_sync(
        test_file_path=args.test_file,
        app_url=args.url,
        supabase_url=args.supabase_url,
        supabase_anon_key=args.supabase_anon_key,
        supabase_service_key=args.supabase_service_key,
        headless=not args.headed,
    )

    if args.json:
        print(json.dumps(results.to_dict(), indent=2))
    else:
        print(f"\n{'=' * 60}")
        print(f"  RESULTS: {results.passed} passed, {results.failed} failed, {results.skipped} skipped")
        print(f"  Duration: {results.total_duration_ms:.0f}ms")
        print(f"{'=' * 60}")

    sys.exit(1 if results.failed > 0 else 0)
